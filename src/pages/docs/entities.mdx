---
title: Entities File Settings
shortTitle: Entities
description: Settings for scaffolding out an entity for your Web API.
---

## Entities

A list of database entities in your project. These entities are added as dbsets to your database context, so they translate 1:1 to tables in your database. 
With that said, if you want to create an aggregate, you can scaffold out an entity and update it accordingly to reflect that aggregate yourself (e.g. remove the db set).

## Entity Properties

| Name       | Required | Description                                                  | Default                          |
| ---------- | -------- | ------------------------------------------------------------ | -------------------------------- |
| Name       | Yes      | The name of the entity                                       | *None*                           |
| Properties | Yes      | A list of properties assigned to your entity described in the [entity properties](#properties) section.| *None*                           |
| [Features](#features)   | Yes      | This is a list of features that you want to add for a particular entity. | *None*                           |
| Plural     | No       | The plural of the entity name, if needed (e.g. `Cities` would prevent `Citys`) | *Entity Name appended with an `s`* |
| Lambda     | No       | The value to use in lambda expressions for this entity. | First letter of the entity name. |
| TableName  | No       | The name of the table in the database. | Defaulted to the singular `Name`. |
| Schema     | No       | The schema to use in the database. | *None*, which will equate to `dbo` in SqlServer, `public` in Postgres, or `mydb` in MySQL |

### Properties

A list of properties that can be assigned to an entity.


| Name               | Required | Description                                                  | Default                          |
| ------------------ | -------- | ------------------------------------------------------------ | -------------------------------- |
| Name               | Yes      | The name of the property                                     | *None*                           |
| Type               | Yes      | The data type for the property. These are *not* case sensitive and they can be set to nullable with a trailing `?`. All standard C# data types can be used here. You even do custom properties like classes that act as foreign keys for instance. | *None*                           |
| CanFilter          | No       | Will set the property to be filterable in the API endpoint when set to true. | false                            |
| CanSort            | No       | Will set the property to be filterable in the API endpoint when set to true. | false                            |
| IsRequired         | No       | When true, the property will be set as required in the database. | false<br/>*true for primary key* |
| ColumnName         | No       | The database field name for the given property. | *None* |
| CanManipulate      | No       | When set to false, you will not be able to update this property when calling the associated endpoint. When set to `false`, the property will be able to be established when using the POST endpoint, but will not be able to be updated after that. This is managed by the DTOs if you want to manually adjust this. | true<br/>*false for primary key* |
| DefaultValue       | No       | Allows you to add a default value to a property. Note that it should be entered exactly as you'd want it, so a string would be something like `"My Default Value"`, a bool might be `true`, and an int might be `0` | *None*                           |
| ForeignEntityName         | No       | Captures the name of the entity this property is linked to as a foreign key. | *None* |
| ForeignEntityPlural         | No       | The plural value for the foreign entity, if applicable. | *Entity Name appended with an `s`* |


> ðŸ”‘ Note that as v0.12+, you do not need to add a primary key property to your entities as they will automatically be inherited from the `BaseEntity` 

<!-- | Auditable          | No       | This will determine if an entity is auditable or not. See [Auditable Entities](#auditable-entities) for more information | false                            | -->

### Features

| Name       | Required | Description                                                  | Default                          |
| ---------- | -------- | ------------------------------------------------------------ | -------------------------------- |
| Type       | Yes      | The type of feature you want to add. The accepted values are `AdHoc`, `GetRecord`, `GetList`, `DeleteRecord`, `UpdateRecord`, `PatchRecord`, `AddRecord`, and `CreateRecord` (same as `AddRecord` but available as an alias in case you can't remember!)                               | *None*                           |
| Policies   | Yes      | A list of policies that should be applied ito your feature. Note that these policies dictate **client** permissions, not user permissions, which should be handled inside your project. | *None*                           |


`GetRecord`, `GetList`, `DeleteRecord`, `UpdateRecord`, `PatchRecord`, `AddRecord`, and `AddListByFk` are all standard CRUD features along with their endpoints and associated tests. 

> â„¹ DTOs, validators, profiles and functional test routes associated to all features will be added regardless of whether or not a given feature was added. This is due to the complexity of all 
the minute management around handling these so dynamically. Feel free to delete whatever you're not using.

#### AddListByFk Feature
The `AddListByFk` will let you add a list or batch of records using a foreign key. For example, you can add a list of ingredients for a recipe, based on the id of a recipe.

| Name       | Required | Description                                                  | Default                          |
| ---------- | -------- | ------------------------------------------------------------ | -------------------------------- |
| BatchPropertyName | Yes     | The name of the property on the foreign entity you are doing a batch add on. | *None*        
| BatchPropertyType | Yes     | The data type of the the property you are doing the batch add on. This is for a FK property, so probably a Guid or int.| *None*        
| ParentEntity | Yes | The name of the parent entity that the FK you using is associated to. For example, if you had a FK of `EventId`, the parent entity might be `Event`. Leave null if you're not batching on a FK. | *None*      
| BatchPropertyDbSetName | Yes | The name of the DbSet for the FK you are doing a batch add on. Generally, the plural of the FK entity. Leave null if you're not batching on a FK.| *None*        


#### Ad Hoc Features
You can also add ad hoc skeletons with the `AdHoc` type. For `AdHoc` features, there's a bit more that needs to be done. In addition to `Type` above, you'll want to provide the below:

| Name       | Required | Description                                                  | Default                          |
| ---------- | -------- | ------------------------------------------------------------ | -------------------------------- |
| Name | Yes     | The name of the feature. This is the name of the feature's method and would generally be something like `AddCustomer` or `GetCustomer`. | *None*        
| Command | Yes     | The name of the command. This is the name of the feature's class and would generally be something like `AddCustomerCommand` or `GetCustomerQuery`.| *[NAME]Command*        
| EntityPlural | No | The plural name of the entity that the feature will be added to (should match the name in the `Domain` directory). You can leave this blank to add it to the `Domain` directory directly. | *[ENTITYNAME]s*      
| ResponseType | No | Is the type of response that this command will return. This could be any C# type that you want, or even a custom type if you want, but in that case, you'll need to add a using statement for it manually. | *bool*        


> You can also add any of the above features after the fact using the [`add:feature` command](/docs/add-feature).

### Policies Properties

| Name               | Required | Description                                                  | Default                          |
| ------------------ | -------- | ------------------------------------------------------------ | -------------------------------- |
| Name               | Yes      | The name of the policy (e.g. `CanReadPatient`). | *None*   |
| PolicyType         | Yes      | The type of policy that will be used. The only valid policy type at the moment is `scope` to authorize based on a scope. | *None*   |
| PolicyValue        | Yes      | The value of the policy that is going to be added (e.g. `patients.read`). | *None*   |


## Entity Example
This example would create a supplier entity with several properties. Note:
- The `SupplierId` is marked as a primary key
- We have normal and nullable primitives in the `Type` option
- We have marked the properties as sortable and filterable
- We have given a default value for `IsVip`
- We are adding all the available features except for `PatchRecord`. We're also adding an `AdHoc` feature for use for batch adding suppliers.

```yaml
Entities:
  - Name: Supplier
    Features:
    - Type: AddRecord
    - Type: GetRecord
    - Type: GetList
    - Type: UpdateRecord
    - Type: DeleteRecord
    - Type: AddListByFk
      BatchPropertyName: OrganizationId
      BatchPropertyType: Guid
      ParentEntity: Organization
    - Type: AdHoc
      Name: MySpecialLookup
      Command: MySpecialLookupQuery
      EntityPlural: Suppliers
    Properties:
      - Name: SupplierId
        IsPrimaryKey: true
        Type: int
        CanFilter: true
        CanSort: true
      - Name: Name
        Type: string
        CanFilter: true
        CanSort: true
      - Name: EmployeeCount
        Type: int?
        CanFilter: true
        CanSort: true
      - Name: CreationDate
        Type: datetime?
        CanFilter: true
        CanSort: true
      - Name: SupplierType
        Type: int?
        CanFilter: true
        CanSort: true
      - Name: IsVip
        Type: bool?
        CanFilter: true
        CanSort: true
        DefaultValue: false
      - Name: OrganizationId
        Type: Guid
        ForeignEntityName: Organization
```

## Example With Foreign Key
Foreign keys can be added in any of the below ways. At a high level, you'll notice there is a syntax for adding the `1` relationship type and the `many` relationship type.

### One to One Relationships
```yaml
Entities:
  - Name: User
    Properties:
    - Name: Name
      Type: string
    - Name: UserProfileId
      Type: Guid
      ForeignEntityName: UserProfile
      ForeignEntityPlural: UserProfiles
  - Name: UserProfile
    Properties:
    - Name: Name
      Type: string
    - Name: UserId
      Type: Guid
      ForeignEntityName: User
      ForeignEntityPlural: Users
```

### One to Many Relationships
Here, we have a `Blog` with many `Posts`. The `Type` of the foreign id doesn't have to be a Guid, but is in this example. 
Additionally, the many `Posts` can be any collection that works for a normal .NET relationship, in this example, an `ICollection`.

```yaml
Entities:
  - Name: Blog
    Properties:
    - Name: Name
      Type: string
    - Name: PostId
      Type: Guid
      ForeignEntityName: Post
      ForeignEntityPlural: Posts
  - Name: Post
    Properties:
    - Name: Name
      Type: string
    - Name: Blogs
      Type: ICollection<Blog>
```


### Many to Many Relationships
Here, we have many `Books` that can also have many `Categories`. Like the One to Many relationship, the `Type` can be any collection that works for a normal .NET relationship.

```yaml
Entities:
  - Name: Book
    Properties:
    - Name: Name
      Type: string
    - Name: Categories
      Type: ICollection<Category>
  - Name: Category
    Properties:
    - Name: Name
      Type: string
    - Name: Books
      Type: ICollection<Book>
```

### Composite Keys
For the time being, composite keys can not be created using Craftsman commands. With that said, you are more than welcome to scaffold out an entity with one of the keys and then 
modify the generated entity, repository, tests, etc. to accommodate that composite key.



## Policies
Something like the below would add policies to your features.

```yaml
  Entities:
  - Name: Recipe
    Features:
    - Type: GetList
      Policies:
      - Name: RecipesReadOnly
        PolicyType: scope
        PolicyValue: recipemanagement.readonly
    - Type: GetRecord
      Policies:
      - Name: RecipesReadOnly
        PolicyType: scope
        PolicyValue: recipemanagement.readonly
    - Type: AddRecord
      Policies:
      - Name: RecipesReadOnly
        PolicyType: scope
        PolicyValue: recipemanagement.readonly
    - Type: UpdateRecord
      Policies:
      - Name: RecipesReadOnly
        PolicyType: scope
        PolicyValue: recipemanagement.readonly
    - Type: DeleteRecord
      Policies:
      - Name: RecipesFullAccess
        PolicyType: scope
        PolicyValue: recipemanagement.fullaccess
```